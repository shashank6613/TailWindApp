pipeline {
    agent any

    environment {
        AWS_CREDENTIALS_ID = 'aws-creds'
        CLUSTER_NAME = 'app-clus'
        REGION = 'us-west-2'
    }

    stages {
        stage('Configure AWS CLI') {
            steps {
                script {
                    withCredentials([aws(credentialsId: 'aws-creds', var: 'AWS_CREDENTIALS')]) {
                        echo "‚öôÔ∏è Configuring AWS CLI using Jenkins credentials..."
                        sh """
                            # Configure AWS CLI using credentials from Jenkins
                            aws configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
                            aws configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
                            aws configure set default.region ${REGION}
                            echo "‚úÖ AWS CLI configured."
                        """
                    }
                }
            }
        }

        stage('Check for Existing EKS Cluster') {
            steps {
                script {
                    echo "üîç Checking if EKS cluster '${CLUSTER_NAME}' already exists..."
                    withAWS(credentials: "${AWS_CREDENTIALS_ID}", region: "${REGION}") {
                        def clusterStatus = sh(
                            script: """
                                aws eks describe-cluster \
                                    --name ${CLUSTER_NAME} \
                                    --region ${REGION} \
                                    --query 'cluster.status' \
                                    --output text || echo "NOTFOUND"
                            """,
                            returnStdout: true
                        ).trim()

                        if (clusterStatus == "ACTIVE" || clusterStatus == "CREATING") {
                            echo "‚úÖ Cluster '${CLUSTER_NAME}' already exists with status: ${clusterStatus}"
                            currentBuild.result = 'SUCCESS'
                            return
                        } else {
                            echo "üöÄ Cluster not found. Proceeding to creation..."
                        }
                    }
                }
            }
        }

        stage('Create EKS Cluster') {
            when {
                expression {
                    currentBuild.result != 'SUCCESS'
                }
            }
            steps {
                script {
                    withAWS(credentials: "${AWS_CREDENTIALS_ID}", region: "${REGION}") {
                        echo "üöÄ Creating new EKS cluster from configuration file..."
                        sh """
                            set -e
                            eksctl create cluster -f Scripts/cluster-config.yaml
                        """
                    }
                }
            }
        }

        stage('Create IAM Identity Mapping') {
            steps {
                script {
                    withCredentials([aws(credentialsId: 'aws-creds', var: 'AWS_CREDENTIALS')]) {
                        echo "‚öôÔ∏è Creating IAM identity mapping for the EKS cluster..."
                        sh """
                            eksctl create iamidentitymapping \
                                --cluster app-clus \
                                --region us-west-2 \
                                --arn arn:aws:iam::799344209838:role/Project-Role-K8 \
                                --username ubuntu \
                                --group system:masters
                    
                            echo "‚úÖ IAM identity mapping created."
                        """
                    }
                }
            }
        }

        stage('Update kubeconfig') {
            steps {
                script {
                    echo "üîÑ Updating kubeconfig for EKS cluster '${CLUSTER_NAME}'..."
                    withAWS(credentials: "${AWS_CREDENTIALS_ID}", region: "${REGION}") {
                        sh """
                            aws eks update-kubeconfig \\
                            --name ${CLUSTER_NAME} \\
                            --region ${REGION} \\
                            --alias ${CLUSTER_NAME}
                        """
                        echo '‚úÖ kubeconfig updated successfully.'

                        echo '‚úÖ Varifying connectivity.'

                        sh "kubectl get nodes"
                    }
                }
            }
        }

        stage('Wait for Node Readiness') {
            steps {
                script {
                    withAWS(credentials: "${AWS_CREDENTIALS_ID}", region: "${REGION}") {
                    echo "‚è≥ Waiting for EKS nodes to become ready..."
                        timeout(time: 10, unit: 'MINUTES') {
                            waitUntil {
                                def readyNodes = sh(
                                    script: "kubectl get nodes --no-headers | grep 'Ready' | wc -l",
                                    returnStdout: true
                                ).trim().toInteger()
                                echo "Nodes Ready: ${readyNodes}"
                                return readyNodes > 0
                            }
                        }
                    }
              
                    echo "‚úÖ EKS nodes are ready."
                }
            }
        }

        stage('Create Kubernetes DB Secret') {
            steps {
                withCredentials([file(credentialsId: 'db-secrets-file', variable: 'DB_SECRETS_FILE')]) {
                    script {
                        withAWS(credentials: 'aws-creds', region: REGION) {
                            echo "üîê Creating Kubernetes secret for database credentials..."
                            sh """
                                kubectl create secret generic db-credentials \
                                  --from-env-file=${DB_SECRETS_FILE} \
                                  -n default --dry-run=client -o yaml | kubectl apply -f -
                            """
                        }
                    }
               }
            }
        }

        stage('Install Argo CD Components') {
            steps {
                script {
                    withAWS(credentials: 'aws-creds', region: REGION) {
                        sh 'kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -'

                        // The fix is here: using 'returnStatus: true' to allow non-zero exit code.
                        sh(
                            script: 'curl -sL https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.34.0/install.sh | bash -s v0.34.0',
                            returnStatus: true
                        )

                        echo 'Installing Operator Lifecycle Manager (OLM)...'
                        sh 'curl -sL https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.34.0/install.sh | bash -s v0.34.0'
                    
                        // Wait for OLM to be ready to ensure the next step doesn't fail.
                        echo 'Waiting for OLM to be ready...'

                        // Find the name of the dynamically created installplan and store it in a variable.
                        def installPlanName = sh(
                            script: "kubectl get installplan -n olm -o jsonpath='{.items[0].metadata.name}'",
                            returnStdout: true
                        ).trim()

                        sh """kubectl wait --for=jsonpath='{.status.phase}'=Succeeded installplan/${installPlanName} -n olm --timeout=7m"""

                        echo 'Installing Argo CD Kubernetes Operator...'
                        sh 'kubectl create -f https://operatorhub.io/install/argocd-operator.yaml'

                        // Wait for the Argo CD Operator to be ready
                        echo 'Waiting for Argo CD Operator to be ready...'
                        sh 'kubectl wait --for=condition=Available deployment/argocd-operator-controller-manager -n argocd --timeout=10m'

                        // Create the Argo CD Instance Custom Resource (CR).
                         echo 'Creating the Argo CD Instance from file...'
                        sh 'kubectl apply -f ArgoCD-config/argocd-instance.yaml'
                    }
                }
            }
        }
    }

    post {
        success {
            echo '‚úÖ EKS cluster creation  completed (or already existed).'
        }
        failure {
            echo '‚ùå EKS cluster creation job failed.'
        }
    }
}




